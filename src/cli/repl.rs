//! Minimal interactive REPL for **gammaLoop** built on `rustyline` **with autocompletion**
//! -----------------------------------------------------------------------------
//! *No external “clap‑repl” crate required – this remains an in‑tree helper.*
//!
//! ## Cargo.toml additions
//! ```toml
//! rustyline   = "12"   # line‑editing + completion API
//! shell-words = "1.1"  # shell‑style tokenisation
//! ```
//! (Keep `clap = { version = "4", features = ["derive"] }` already present.)
//!
//! ## Public API
//! Call `repl::start(prompt, pre_args)` where
//! * `prompt`    – what to print before each line (e.g. "gammaLoop")
//! * `pre_args`  – top‑level flags that should be prepended on every call
//!
//! Example wiring in `cli.rs`:
//! ```rust
//! match cli.command {
//!     Some(Commands::Repl) => repl::start("gammaLoop", &[])?;
//!     _ => run_once(cli)?,
//! }
//! ```
//!
//! -----------------------------------------------------------------------------

use color_eyre::Report;
use rustyline::completion::{Completer, Pair};
use rustyline::highlight::Highlighter;
use rustyline::hint::{Hint, Hinter};
use rustyline::history::FileHistory;
use rustyline::validate::Validator;
use rustyline::Helper;
use rustyline::{error::ReadlineError, Editor};

use shell_words::split;

use crate::cli::Cli;
use clap::{CommandFactory, Parser};

/// `ClapHelper` exposes simple tab‑completion for subcommands and flags derived
/// from the `Cli` type (generated by `clap` derive macros). It is **stateless**
/// and cheap to clone.
struct ClapHelper {
    cmd: clap::Command, // cached root command meta
}

impl ClapHelper {
    fn new() -> Self {
        Self {
            cmd: Cli::command(),
        }
    }

    /// Collect possible completions for the current *prefix*.
    fn suggestions(&self, prefix: &str) -> Vec<Pair> {
        let mut out = Vec::new();
        // top‑level subcommands
        for sc in self.cmd.get_subcommands() {
            let name = sc.get_name();
            if name.starts_with(prefix) {
                out.push(Pair {
                    display: name.into(),
                    replacement: name.into(),
                });
            }
        }
        // global flags / options
        for arg in self.cmd.get_arguments() {
            // long flags
            if let Some(l) = arg.get_long() {
                let long_form = format!("--{l}");
                if long_form.starts_with(prefix) {
                    out.push(Pair {
                        display: long_form.clone(),
                        replacement: long_form,
                    });
                }
            }
            // short flags
            if let Some(s) = arg.get_short() {
                let short_form = format!("-{s}");
                if short_form.starts_with(prefix) {
                    out.push(Pair {
                        display: short_form.clone(),
                        replacement: short_form,
                    });
                }
            }
        }
        out
    }
}

// ---------------- rustyline trait impls ------------------------------------
impl Completer for ClapHelper {
    type Candidate = Pair;

    fn complete(
        &self,
        line: &str,
        pos: usize,
        _ctx: &rustyline::Context<'_>,
    ) -> rustyline::Result<(usize, Vec<Pair>)> {
        let (start, prefix) = match line[..pos].rfind(|c: char| c.is_whitespace()) {
            Some(idx) => (idx + 1, &line[idx + 1..pos]),
            None => (0, &line[..pos]),
        };
        Ok((start, self.suggestions(prefix)))
    }
}

impl Hinter for ClapHelper {
    type Hint = String;
    fn hint(&self, _line: &str, _pos: usize, _ctx: &rustyline::Context<'_>) -> Option<String> {
        None // no dynamic hints for now
    }
}
impl Highlighter for ClapHelper {}
impl Helper for ClapHelper {}
impl Validator for ClapHelper {}

// ---------------------------------------------------------------------------
// Public function -----------------------------------------------------------
// ---------------------------------------------------------------------------

/// Start the interactive loop. Returns `Ok(())` on EOF / `quit`.
pub fn start(prompt_prefix: &str, pre_args: &[String]) -> Result<(), Report> {
    // editor with our helper
    let mut rl = Editor::<ClapHelper, FileHistory>::new()?;
    rl.set_helper(Some(ClapHelper::new()));

    // ~~ History file ~~
    if let Some(home) = std::env::var_os("HOME") {
        let hist_path = std::path::Path::new(&home).join(".gammaLoop_history");
        rl.load_history(&hist_path).ok();
        struct Guard<'a> {
            path: &'a std::path::Path,
            rl: &'a mut Editor<ClapHelper, FileHistory>,
        }
        impl<'a> Drop for Guard<'a> {
            fn drop(&mut self) {
                let _ = self.rl.save_history(self.path);
            }
        }
        let _guard = Guard {
            path: &hist_path,
            rl: &mut rl,
        };

        // main loop --------------------------------------------------------
        loop {
            let line = match rl.readline(&format!("{prompt_prefix}> ")) {
                Ok(l) => l,
                Err(ReadlineError::Interrupted) => {
                    println!();
                    continue;
                } // Ctrl‑C
                Err(ReadlineError::Eof) => {
                    println!();
                    break;
                } // Ctrl‑D
                Err(e) => return Err(e.into()),
            };

            let trimmed = line.trim();
            if trimmed.is_empty() {
                continue;
            }
            if matches!(trimmed, "exit" | "quit") {
                break;
            }
            rl.add_history_entry(trimmed);

            // tokenise respecting quotes / escapes
            let tokens = match split(trimmed) {
                Ok(t) => t,
                Err(e) => {
                    eprintln!("{e}");
                    continue;
                }
            };

            // reconstruct argv: exe name + pre‑args + tokens
            let mut argv: Vec<String> = Vec::with_capacity(1 + pre_args.len() + tokens.len());
            argv.push("gammaLoop".into());
            argv.extend_from_slice(pre_args);
            argv.extend(tokens.into_iter());

            match Cli::try_parse_from(&argv) {
                Ok(parsed) => parsed.run()?,
                Err(e) => eprintln!("{e}"),
            }
        }
    }
    Ok(())
}
